from __future__ import annotations

import argparse
import csv
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple


def _parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="BONUS: study the effect of number of agents on performance."
    )
    p.add_argument("--scenario", type=str, default="balance")
    p.add_argument("--algos", nargs="+", default=["mappo", "ippo", "cppo"])
    p.add_argument("--n_agents_list", nargs="+", type=int, default=[2, 3, 4, 6, 8])
    p.add_argument("--seeds", type=int, default=5)
    p.add_argument("--iters", type=int, default=150)
    p.add_argument("--train_batch_size", type=int, default=60000)
    p.add_argument("--num_envs", type=int, default=300)
    p.add_argument("--max_steps", type=int, default=200)
    p.add_argument("--device", choices=["cuda", "cpu"], default="cuda")
    p.add_argument("--buffer_device", choices=["cpu", "cuda"], default="cpu")
    p.add_argument(
        "--out_dir",
        type=str,
        default="results_bonus",
        help="Output root for bonus experiments (will create subfolders per n_agents).",
    )
    p.add_argument(
        "train_args",
        nargs=argparse.REMAINDER,
        help="Extra args forwarded to experiments.train_balance (prefix with `--`).",
    )
    return p.parse_args()


def _read_last_metric(csv_path: Path, key: str = "episode_return_mean") -> float:
    with csv_path.open("r", newline="", encoding="utf-8") as f:
        r = csv.DictReader(f)
        last = None
        for row in r:
            last = row
        if last is None:
            raise ValueError(f"Empty CSV: {csv_path}")
        return float(last[key])


def _mean_std(xs: List[float]) -> Tuple[float, float]:
    import math

    m = sum(xs) / len(xs)
    var = sum((x - m) ** 2 for x in xs) / len(xs)
    return m, math.sqrt(var)


def _write_summary_csv(path: Path, rows: List[Dict]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(
            f,
            fieldnames=[
                "scenario",
                "algo",
                "n_agents",
                "seeds",
                "iters",
                "train_batch_size",
                "num_envs",
                "max_steps",
                "final_return_mean",
                "final_return_std",
            ],
        )
        w.writeheader()
        for row in rows:
            w.writerow(row)


def _write_latex_table(path: Path, rows: List[Dict]) -> None:
    # Group by n_agents, then include a column per algorithm.
    algos = sorted({r["algo"] for r in rows})
    n_agents_list = sorted({int(r["n_agents"]) for r in rows})
    lookup = {(r["algo"], int(r["n_agents"])): (r["final_return_mean"], r["final_return_std"]) for r in rows}

    path.parent.mkdir(parents=True, exist_ok=True)
    with path.open("w", encoding="utf-8") as f:
        f.write("% Auto-generated by experiments/bonus_agent_scaling.py\n")
        f.write("\\begin{table}[h!]\n\\centering\n")
        f.write("\\caption{Bonus: Final mean episode return (mean$\\pm$std over seeds) vs number of agents.}\n")
        f.write("\\label{tab:agent_scaling}\n")
        f.write("\\begin{tabular}{l" + "c" * len(algos) + "}\n")
        f.write("\\toprule\n")
        f.write("n\\_agents & " + " & ".join([a.upper() for a in algos]) + " \\\\\n")
        f.write("\\midrule\n")
        for n in n_agents_list:
            cells = []
            for a in algos:
                m, s = lookup.get((a, n), (float("nan"), float("nan")))
                cells.append(f"{m:.2f} $\\pm$ {s:.2f}")
            f.write(f"{n} & " + " & ".join(cells) + " \\\\\n")
        f.write("\\bottomrule\n\\end{tabular}\n\\end{table}\n")


def main() -> None:
    args = _parse_args()
    root = Path(__file__).resolve().parents[1]
    out_root = Path(args.out_dir)

    # Normalize forwarded args: strip a leading "--" if present.
    extra = list(args.train_args)
    if extra and extra[0] == "--":
        extra = extra[1:]

    # Run sweeps
    for n_agents in args.n_agents_list:
        for algo in args.algos:
            out_dir = out_root / f"n_agents_{n_agents}"
            cmd = [
                sys.executable,
                "-m",
                "experiments.run_paper_like",
                "--algo",
                algo,
                "--seeds",
                str(args.seeds),
                "--device",
                args.device,
                "--buffer_device",
                args.buffer_device,
                "--iters",
                str(args.iters),
                "--train_batch_size",
                str(args.train_batch_size),
                "--num_envs",
                str(args.num_envs),
                "--max_steps",
                str(args.max_steps),
                "--n_agents",
                str(n_agents),
                "--out_dir",
                str(out_dir),
            ]
            if extra:
                cmd.append("--")
                cmd.extend(extra)
            print(f"Running: {' '.join(cmd)}")
            subprocess.check_call(cmd, cwd=str(root))

    # Summarize final returns (last iteration)
    rows: List[Dict] = []
    for n_agents in args.n_agents_list:
        for algo in args.algos:
            per_seed = []
            for seed in range(args.seeds):
                csv_path = out_root / f"n_agents_{n_agents}" / args.scenario / algo / f"seed_{seed}.csv"
                per_seed.append(_read_last_metric(csv_path))
            m, s = _mean_std(per_seed)
            rows.append(
                {
                    "scenario": args.scenario,
                    "algo": algo,
                    "n_agents": n_agents,
                    "seeds": args.seeds,
                    "iters": args.iters,
                    "train_batch_size": args.train_batch_size,
                    "num_envs": args.num_envs,
                    "max_steps": args.max_steps,
                    "final_return_mean": m,
                    "final_return_std": s,
                }
            )

    summary_csv = out_root / "agent_scaling_summary.csv"
    _write_summary_csv(summary_csv, rows)

    # Plot
    import matplotlib.pyplot as plt

    fig_dir = out_root / "figures"
    fig_dir.mkdir(parents=True, exist_ok=True)

    plt.figure(figsize=(9, 5))
    for algo in args.algos:
        xs = []
        ys = []
        yerr = []
        for n_agents in args.n_agents_list:
            r = next(r for r in rows if r["algo"] == algo and int(r["n_agents"]) == int(n_agents))
            xs.append(int(n_agents))
            ys.append(float(r["final_return_mean"]))
            yerr.append(float(r["final_return_std"]))
        plt.errorbar(xs, ys, yerr=yerr, marker="o", capsize=3, label=algo)

    plt.xlabel("Number of agents (n_agents)")
    plt.ylabel("Final mean episode return")
    plt.title(f"{args.scenario}: agent-count scaling (meanÂ±std over seeds)")
    plt.legend()
    out_path = fig_dir / f"{args.scenario}_agent_scaling.png"
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    print(f"Saved: {out_path}")
    print(f"Saved: {summary_csv}")

    # LaTeX table for the report
    table_path = out_root / "agent_scaling_table.tex"
    _write_latex_table(table_path, rows)
    print(f"Saved: {table_path}")


if __name__ == "__main__":
    main()

